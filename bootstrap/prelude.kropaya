%let Prelude =
  ※ The start of the prelude 'contains' a number of Edges which are inserted initially by magic
  ※ Many of these are for basic types, and other things that are needed to get the initial machinery running

  ※ Some common types

  %let
    U = %edge magic-u
    ※ U notionally has the type ∀x. U x.
    ※ It is the type of all positive (value) x.
    F = %edge magic-f
    ※ F notionally has the type ∀x. F x.
    ※ It is the type of all negative (computation) x.
    ※ (%return ⌜U x⌝) fits in a negative hole that wants an x
    ※ That is, %return makes a simple computation out of a value.
    ※ (%thunk ⌜F x⌝) fits in a positive hole that wants an ⌜F x⌝
    ※ That is, %thunk wraps a simple computation in a value.
    ※ (%force ⌜U (F a)⌝) produces an ⌜a⌝
    ※ That is, %force unwraps a thunk and then runs the resulting computation.
    ※ Computation arrows (eg U a → F b) notionally are of type (U a ⇒ F b).
    ※ They can thus be pattern matched on the left, and destructed on the right.
    ※ Value arrows (eg U a → U b) notionally are of type (U a ⇒ U b).
    ※ They can be pattern matched on both the left and the right.
  %end

  %let μNum.
    ⊥ = %edge magic-bottom.
    ⊤ = %edge magic-top.
    Text = %edge magic-text.
    Num = %edge magic-num. ※ For now, num is just int. Fairly soon we will need an actual numerical hierarchy. I envisage three separate sets of typeclasses - one based on machine types, one based on infinite precision types, and one based on group theory.
    Int = Num.
  %end

  %let maybe = ∃a. <&some: a, &none>.

  %let either = ∃a. ∃b. <&left: a, &right: b>.

  %let μtruth and or not.
    truth = <&true, &false>.
    and^-: U truth → U truth → F truth.
    and^- <&true> <&true> = %return <&true>.
    and^- _ _ = %return <&false>.
    and^+: U truth → U truth → U truth.
    and^+ <&true> <&true> = <&true>.
    and^+ _ _ = <&false>.
    or^-: U truth → U truth → F truth.
    or^- <&false> <&false> = %return <&false>.
    or^- _ _ = %return <&true>.
    or^+: U truth → U truth → U truth.
    or^+ <&false> <&false> = <&false>.
    or^+ _ _ = <&true>.
    not^-: U truth → F truth.
    not^- <&true> = %return <&false>.
    not^- <&false> = %return <&true>.
    not^+: U truth → U truth.
    not^+ <&true> = <&false>.
    not^+ <&false> = <&true>.
  %end

  %let
    if^-: ∀a. U truth → U (U (F a)) → U (U (F a)) → F a.
    if^- condition then else = (condition {&true ⇒ \x → %force then, &false ⇒ \x → %force else}) &true.
    if^-: ∀a b. U truth → U (U (F a)) → U (U (F b)) → F (either a b).
    if^- condition then else = (condition {&true ⇒ \x → <&left ⇒ %force then>, &false ⇒ \x → <&right ⇒ %force else>}) &true.
    if^+: ∀a. U truth → U (U a) → U (U a) → U a.
    if^+ condition then else = condition {&true ⇒ then, &false ⇒ else}.
    if^+: ∀a b. U truth → U (U a) → U (U b) → U (either a b).
    if^+ condition then else = condition {&true ⇒ <&left ⇒ then>, &false ⇒ <&right ⇒ else>}.
  %end



  %let list = ∃y. μx. <&end, &cons: {&car: y, &cdr: x}>.
  %let
    Cons: ∃x. x ⊸ list ⊸ list.
    Cons x lst = <&cons ⇒ {&car ⇒ x, &cdr ⇒ lst}>.
  %end
  %let non-empty-list-of-y = ∀q r. ∃(x: q → r). ∃y. <&cons: {&car: y, &cdr: x y}>.
  %let list-of-2-or-more = non-empty-list-of-y (non-empty-list-of-y (list)).
  %let arbitrary-list = μx. <&end, &cons: ∃y. {&car: y, &cdr: x}>.
  ※ arbitrary-list is used like so:
  ※ <&cons ⇒ {&car ⇒ 3, &cdr ⇒ <&cons ⇒ {&car ⇒ "Foo", &cdr ⇒ <&end>}: arbitrary-list Text>}: arbitrary-list Number>

  %let BinaryNat = μnum start done.
    num = <&zero: num, &one: num, &done>.
    start = <&one: num, &zero: done>.
    done = <&done>.
  %end
  %let nat = BinaryNat#start.
  %let Foldable = ∃foldable. μfoldr foldMap foldrType foldMapType Foldable.
    foldMapType = ∀m. ∃(x: Monoid m). (foldable → m) → foldable → m.
    foldMap: foldMapType.
    foldMap f = foldr (x#mappend ∘ f) x#mempty.

    foldrType = ∀a b. (a → b → b) → b → foldable → b.
    foldr: foldrType.
    foldr f z t = appEndo (foldMap (Endo ∘ f) t) z 

    foldl: ∀a b. (b → a → b) → b → foldable → b.
    foldl f z t = appEndo (getDual (foldMap (Dual ∘ Endo ∘ flip f) t)) z.
  %end

  %let
    case : ∀ match-label match-type other-cases result. {match-label:(match-type→result) |other-cases} → <match-label:match-type> → result.
    case pattern it = (match-label pattern) (match-label it).

    id : ∀x. x → x.
    id x = x
  %end

  ※ Usage:
  ※ show : either Text Text → Eff IO
  ※ show result = print (case {&left ⇒ \x → "error: #{x}", &right ⇒ id} result)

  %let Quotient = ∃a. ∃(eq: a → a → truth). ※ Properties we want to be able to state: ∀m n o. eq m m. eq m n ≡ eq n m. (eq m n ∧ eq n o) → eq m o.
  %end

  ※%let μget set lengths volume.
  ※  %let shape = list Int.
  ※  %let array = ∃(s:shape) type. %edge magic-array-body.
  ※  get: ∀type. Int → array shape type → maybe type.
  ※  get index the-array = %edge magic-array-get.
  ※
  ※  set: ∀type. Int → array shape type → type → either Text type.
  ※  set index the-array the-value = %edge magic-array-set.
  ※
  ※  lengths: ∀type. array shape type → list Int.
  ※  lengths _ = shape.
  ※
  ※  volume: ∀type. array shape type → Int.
  ※  volume _ = foldl shape (+) 0.
  ※%end


  ※ For now, we do map as a naive association-list.
  %let μmap keys values filter set get mapcar.
    map = ∃k v comparator (quotient: Quotient k comparator). list {&key: k, &value: v}.

    get: ∀keys values c q. keys → map keys values c q → maybe values.
    get key the-map = case { &end ⇒ \x → <&none>, &cons ⇒ (\x → (if (c the-key (&key (&car x))) (thunk (<&some⇒(&value x)>)) (thunk (get key (&cdr x))))) } the-map.

    set: ∀keys values c q. keys → values → map keys values c q → map keys values c q.
    set key value the-map = <&cons⇒{&car⇒{&key⇒key, &value⇒value}, &cdr⇒filter (\x → not (c the-key x)) the-map}>.
    ※set key value the-map = case {&none ⇒ (\x → (<&cons⇒<&car⇒<&key⇒key, &value⇒value>, &cdr⇒the-map>>: map keys values c q)), &some⇒} (get key the-map)

    filter: ∀keys values c q. (keys → truth) → map keys values c q → map keys values c q.
    filter pred the-map = case { &end ⇒ id, &cons ⇒ \x → (if (pred (&car x)) (thunk (<&cons⇒{&car⇒&car x, &cdr⇒filter pred (&cdr x)}>)) (thunk (filter pred (&cdr x)))) } the-map.

    ※ Use this janky mapcar for now
    mapcar: ∀a b. list a  → (a → b) → list b.
    mapcar in fn = case { &end ⇒ id, &cons ⇒ \x → <&cons⇒{&car⇒(fn (&car x)), &cdr⇒(mapcar (&cdr x))}> } in.

    keys: ∀k v q c. map k v q c  → list k.
    keys the-map = mapcar the-map &key.
    values: ∀k v q c. map k v q c → list v.
    values the-map = mapcar the-map &value.
  %end


  %let μlet lambda juxtaposition quantifier tree pattern type-function type variable literal label singular-row row product sum.
    tree = list <&let: let, &lambda: lambda, &juxtaposition: juxtaposition, &literal: literal, &variable: variable>.
    variable = Text.
    literal = <&text: Text, &number: Num, &product: product, &sum: sum, &singular-row: singular-row, &label: label, &underscore>.
    let = {&root: <&parent, &module: variable>, &quantifiers: list quantifier, &bindings: map variable (list <&judgement: type, &thing: {&pattern: pattern, &rhs: tree}>)}.
    lambda = {&arguments: list variable, &body: tree}.
    juxtaposition = list tree.
    quantifier = {&quantifier: <&forall, &exists, &fresh, &lambda, &mu>, &variables: list <&bare: variable, &constraint: {&variable: variable, &judgement: type}>}.
    pattern = list <&variable: variable, &literal: literal>.
    type-function = {&l: type, &r: type}.
    type = {&quantifiers: list quantifier, &formula: <&fn: type-function, &row: row, &literal: literal>}.
    label = <&literal: Text, &variable: variable>.
    singular-row = {&label: label, &extra: <&type: type, &value: tree, &nothing>}.
    row = {&fixed-rows: list singular-row, &polymorphic-extensions: list variable, &restrictions: list <&variable: variable, &literal-singular-row: singular-row, &literal-row: row>}.
    product = row.
    sum = row.
  %end

  %let
    read: Text → tree.
    read text = %edge magic-read
  %end
%end
