%let Prelude =
  ※ The start of the prelude 'contains' a number of Edges which are inserted initially by magic
  ※ Many of these are for basic types, and other things that are needed to get the initial machinery running

  ※ Some common types

  %let μNum.
    ⊥ = %edge magic-bottom.
    ⊤ = %edge magic-top.
    Text = %edge magic-text.
    Num = %edge magic-num. ※ For now, num is just int. Fairly soon we will need an actual numerical hierarchy. I envisage three separate sets of typeclasses - one based on machine types, one based on infinite precision types, and one based on group theory.
    Int = Num.
  %end

  %let
    U = ∃a. %edge magic-thunk-type.
    ※ Notionally there should be a symmetric type for 'forced' things; it doesn't quite make sense in the current formulation.
    ※ The type declaration would be F = ∃a. %edge magic-force-type.

    ※ Type sig would notionally be thunk: ∀a: a → U a. This does not capture the fact that a is swallowed unevalled though.
    thunk i = %edge magic-thunk.
    force: ∀a: U a → a.
    force i = %edge magic-force.
  %end

  %let maybe = ∃a. <&some: a, &none>.

  %let either = ∃a. ∃b. <&left: a, &right: b>.

  %let μtruth and or not.
    truth = <&true, &false>.
    and: truth → truth → truth.
    and &true &true = &true.
    and _ _ = &false.
    or: truth → truth → truth.
    or &false &false = &false.
    or _ _ = &true.
    not: truth → truth.
    not &true = &false.
    not &false = &true.
  %end

  %let
    if: ∀a b. truth → U a → U b → either a b.
    if condition then else = (condition {&true ⇒ \x → <&left ⇒ force then>, &false ⇒ \x → <&right ⇒ force else>}) _.
    if: ∀a. truth → U a → U a → a.
    if condition then else = (condition {&true ⇒ \x → force then, &false ⇒ \x → force else}) _.
  %end

  %let list = ∃y. μx. <&end, &cons: {&car: y, &cdr: x}>.
  %let arbitrary-list = μx. <&end, &cons: ∃y. {&car: y, &cdr: x}>.
  ※ arbitrary-list is used like so:
  ※ <&cons ⇒ {&car ⇒ 3, &cdr ⇒ <&cons ⇒ {&car ⇒ "Foo", &cdr ⇒ <&end>}: arbitrary-list Text>}: arbitrary-list Number>

  %let Foldable = ∃foldable. μfoldr foldMap.
    foldMap: ∀m. ∃(x: Monoid m). (foldable → m) → foldable → m.
    foldMap f = foldr (x#mappend ∘ f) x#mempty.

    foldr: ∀a b. (a → b → b) → b → foldable → b.
    foldr f z t = appEndo (foldMap (Endo ∘ f) t) z 

    foldl: ∀a b. (b → a → b) → b → foldable → b.
    foldl f z t = appEndo (getDual (foldMap (Dual ∘ Endo ∘ flip f) t)) z.
  %end

  %let
    case : ∀ match-label match-type other-cases result. {match-label:(match-type→result) |other-cases} → <match-label:match-type> → result.
    case pattern it = (match-label pattern) (match-label it).

    id : ∀x. x → x.
    id x = x
  %end

  ※ Usage:
  ※ show : either Text Text → Eff IO
  ※ show result = print (case {&left ⇒ \x → "error: #{x}", &right ⇒ id} result)

  %let Quotient = ∃a. ∃(eq: a → a → truth). ※ Properties we want to be able to state: ∀m n o. eq m m. eq m n ≡ eq n m. (eq m n ∧ eq n o) → eq m o.
  %end

  ※%let μget set lengths volume.
  ※  %let shape = list Int.
  ※  %let array = ∃(s:shape) type. %edge magic-array-body.
  ※  get: ∀type. Int → array shape type → maybe type.
  ※  get index the-array = %edge magic-array-get.
  ※
  ※  set: ∀type. Int → array shape type → type → either Text type.
  ※  set index the-array the-value = %edge magic-array-set.
  ※
  ※  lengths: ∀type. array shape type → list Int.
  ※  lengths _ = shape.
  ※
  ※  volume: ∀type. array shape type → Int.
  ※  volume _ = foldl shape (+) 0.
  ※%end


  ※ For now, we do map as a naive association-list.
  %let μmap keys values filter set get mapcar.
    map = ∃k v comparator (quotient: Quotient k comparator). list {&key: k, &value: v}.

    get: ∀keys values c q. keys → map keys values c q → maybe values.
    get key the-map = case { &end ⇒ \x → <&none>, &cons ⇒ (\x → (if (c the-key (&key (&car x))) (thunk (<&some⇒(&value x)>)) (thunk (get key (&cdr x))))) } the-map.

    set: ∀keys values c q. keys → values → map keys values c q → map keys values c q.
    set key value the-map = <&cons⇒{&car⇒{&key⇒key, &value⇒value}, &cdr⇒filter (\x → not (c the-key x)) the-map}>.
    ※set key value the-map = case {&none ⇒ (\x → (<&cons⇒<&car⇒<&key⇒key, &value⇒value>, &cdr⇒the-map>>: map keys values c q)), &some⇒} (get key the-map)

    filter: ∀keys values c q. (keys → truth) → map keys values c q → map keys values c q.
    filter pred the-map = case { &end ⇒ id, &cons ⇒ \x → (if (pred (&car x)) (thunk (<&cons⇒{&car⇒&car x, &cdr⇒filter pred (&cdr x)}>)) (thunk (filter pred (&cdr x)))) } the-map.

    ※ Use this janky mapcar for now
    mapcar: ∀a b. list a  → (a → b) → list b.
    mapcar in fn = case { &end ⇒ id, &cons ⇒ \x → <&cons⇒{&car⇒(fn (&car x)), &cdr⇒(mapcar (&cdr x))}> } in.

    keys: ∀k v q c. map k v q c  → list k.
    keys the-map = mapcar the-map &key.
    values: ∀k v q c. map k v q c → list v.
    values the-map = mapcar the-map &value.
  %end


  %let μlet lambda juxtaposition quantifier tree pattern type-function type variable literal label singular-row row product sum.
    tree = list <&let: let, &lambda: lambda, &juxtaposition: juxtaposition, &literal: literal, &variable: variable>.
    variable = Text.
    literal = <&text: Text, &number: Num, &product: product, &sum: sum, &singular-row: singular-row, &label: label, &underscore>.
    let = {&root: <&parent, &module: variable>, &quantifiers: list quantifier, &bindings: map variable (list <&judgement: type, &thing: {&pattern: pattern, &rhs: tree}>)}.
    lambda = {&arguments: list variable, &body: tree}.
    juxtaposition = list tree.
    quantifier = {&quantifier: <&forall, &exists, &fresh, &lambda, &mu>, &variables: list <&bare: variable, &constraint: {&variable: variable, &judgement: type}>}.
    pattern = list <&variable: variable, &literal: literal>.
    type-function = {&l: type, &r: type}.
    type = {&quantifiers: list quantifier, &formula: <&fn: type-function, &row: row, &literal: literal>}.
    label = <&literal: Text, &variable: variable>.
    singular-row = {&label: label, &extra: <&type: type, &value: tree, &nothing>}.
    row = list singular-row.
    product = row.
    sum = row.
  %end

  %let
    read: Text → tree.
    read text = %edge magic-read
  %end
%end
