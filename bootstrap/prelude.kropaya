%let Prelude =
  ※ The start of the prelude 'contains' a number of Edges which are inserted initially by magic
  ※ Many of these are for basic types, and other things that are needed to get the initial machinery running

  ※ Some common types

  %let
    U = ∃a. %edge magic-thunk-type.
    ※ Notionally there should be a symmetric type for 'forced' things; it doesn't quite make sense in the current formulation.
    ※ The type declaration would be F = ∃a. %edge magic-force-type.

    ※ Type sig would notionally be thunk: ∀a: a → U a. This does not capture the fact that a is swallowed unevalled though.
    thunk i = %edge magic-thunk.
    force: ∀a: U a → a.
    force i = %edge magic-force.
  %end

  %let maybe = ∃a. <&some: a, &none>.

  %let either = ∃a. ∃b. <&left: a, &right: b>.

  %let μtruth and or not.
    truth = <&true, &false>.
    and: truth → truth → truth.
    and &true &true = &true.
    and _ _ = &false.
    or: truth → truth → truth.
    or &false &false = &false.
    or _ _ = &true.
    not: truth → truth.
    not &true = &false.
    not &false = &true.
  %end

  %let
    if: ∀a b. truth → U a → U b → either a b.
    if condition then else = (condition {&true ⇒ \x → <&left ⇒ force then>, &false ⇒ \x → <&right ⇒ force else>}) _.
    if: ∀a. truth → U a → U a → a.
    if condition then else = (condition {&true ⇒ \x → force then, &false ⇒ \x → force else}) _.
  %end

  %let list = ∃y. μx. <&end, &cons: {&car: y, &cdr: x}>.
  %let arbitrary-list = μx. <&end, &cons: ∃y. {&car: y, &cdr: x}>.
  ※ arbitrary-list is used like so:
  ※ <&cons ⇒ {&car ⇒ 3, &cdr ⇒ <&cons ⇒ {&car ⇒ "Foo", &cdr ⇒ <&end>} ← Text>} ← Number>

  %let Foldable = ∃foldable. μfoldr foldMap.
    foldMap: ∀m. ∃(x: Monoid m). (foldable → m) → foldable → m.
    foldMap f = foldr (x#mappend ∘ f) x#mempty.

    foldr: ∀a b. (a → b → b) → b → foldable → b.
    foldr f z t = appEndo (foldMap (Endo ∘ f) t) z 

    foldl: ∀a b. (b → a → b) → b → foldable → b.
    foldl f z t = appEndo (getDual (foldMap (Dual ∘ Endo ∘ flip f) t)) z.
  %end

  %let
    case : ∀ match-label match-type other-cases result. {match-label:(match-type→result) |other-cases} → <match-label:match-type |other-cases> → result.
    case pattern it = (match-label pattern) (match-label it).

    id : ∀x. x → x.
    id x = x
  %end

  ※ Usage:
  ※ show : either Text Text → Eff IO
  ※ show result = print (case {&left ⇒ \x → "error: #{x}", &right ⇒ id} result)

  %let Quotient = ∃a. ∃(eq: a → a → truth). ※ Properties: ∀m n o. eq m n ≡ eq n m. (eq m n ∧ eq n o) → eq m o.
  %end

  %let μget set lengths volume.
    %let shape = list Int.
    %let array = ∃(s:shape) type. %edge magic-array-body.
    get: ∀type. Int → array shape type → maybe type.
    get index the-array = %edge magic-array-get.

    set: ∀type. Int → array shape type → type → either Text type.
    set index the-array the-value = %edge magic-array-set.

    lengths: ∀type. array shape type → list Int.
    lengths _ = shape.

    volume: ∀type. array shape type → Int.
    volume _ = foldl shape (+) 0.
  %end


  ※ For now, we do map as a naive association-list.
  %let μmap.
    map = ∃k v comparator (quotient: Quotient k comparator). list <&key: k, &value: v>.

    get: ∀keys values c q. keys → map keys values c q → maybe values.
    get key the-map = case { &end ⇒ \x → <&none>, &cons ⇒ (\x → (if (c the-key (&key (&car x))) (thunk (<&some⇒(&value x)>)) (thunk (get key (&cdr x))))) } the-map

    set: ∀keys values c q. keys → values → map keys values c q → map keys values c q.
    set key value the-map = <&cons⇒{&car⇒{&key⇒key, &value⇒value}, &cdr⇒filter (\x → not (c the-key x)) the-map}>.
    ※set key value the-map = case {&none ⇒ (\x → (<&cons⇒<&car⇒<&key⇒key, &value⇒value>, &cdr⇒the-map>>: map keys values c q)), &some⇒} (get key the-map)

    filter: ∀keys values c q. (keys → truth) → map keys values c q → map keys values c q.
    filter pred the-map = case { &end ⇒ id, &cons ⇒ \x → (if (pred (&car x)) (thunk (<&cons⇒{&car⇒&car x, &cdr⇒filter pred (&cdr x)}>)) (thunk (filter pred (&cdr x)))) } the-map.

    keys: ∀k v q c. map k v q c  → list k.
    keys = %edge magic-map-key.
    values: ∀k v q c. map k v q c → list v.
    values = %edge magic-map-value
  %end


  ※ AST types - these are fairly strongly tied to an implementation of read, eval, and mirror
  %types (μ tree forest Name Quantifier Arguments Module Program Coprogram Procedure Function Combinator Let TypeDeclaration TypeBlock TypeValue TypeVariable RowType ApplicationType Expression Literal Product Sum Lookup Juxtaposition)
    forest = array tree.
    tree = <
      &module:     Module,
      &program:    Program,  ※ Eventually: must be total and have termination properties
      &coprogram:  Coprogram, ※ Eventually: must be total and have liveness properties
      &procedure:  Procedure,
      &function:   Function, ※ Functions are pure
    ※  &predicate:  Predicate,  ※ Implement this later
      &combinator: Combinator,
    ※  &method:     Method,  ※ Implement this later
    ※  &multi:      Multi,   ※ Implement this later
      &let:        Let,
      &type:       TypeDeclaration,
      &types:      TypeBlock,
      &expression: Expression
    >.

    Name            = <&literal: Text> ※ Have more kinds of names later - this is needed for doing 'capabilities' the way I want to
    Label           = <&name: Text> ※ Have more kinds of labels later - this is needed for 'label variables' and 'capabilities'
    Quantifier      = <&type: <&lambda, &mu, &forall, &exists, &fresh>, &bound: ∃s∈Shape. array s <&just-name: Name, &name-and-member-of: {&name: Name, &e: TypeValue}>>
    Arguments       = ∃s∈Shape. array s {&name: Name, &type: TypeValue}
    Module          = {&name: Name, &quantifiers: ∃s∈Shape. array s Quantifier, &exports: ∃s∈Shape. array s Name, &code: forest}
    Program         = {&name: Name, &inputs: Arguments, &code: forest}
    Coprogram       = {&name: Name, &inputs: Arguments, &code: forest}
    Procedure       = {&name: Name, &inputs: Arguments, &output: TypeValue, &code: forest}
    Function        = {&name: Name, &inputs: Arguments, &output: TypeValue, &code: forest}
    ※ Predicate      = {&name: Name, &inputs: Arguments, &output: ???, &code: forest}
    Combinator      = {&name: Name, &inputs: Arguments, &output: TypeValue, &code: forest}
    Let             = {&arguments: ∃s∈Shape. array s {&name: Name, &value: Expression}, &code: forest}
    TypeDeclaration = {&name: Name, &inputs: ∃s∈Shape. array s TypeVariable, &value: TypeValue}
    TypeBlock       = {&quantifiers: ∃s∈Shape. array s Quantifier, &declarations: ∃s∈Shape. array s TypeDeclaration}
    TypeValue       = {&quantifiers: ∃s∈Shape. array s Quantifier, &types: <&row: RowType, &product: RowType, &sum: RowType, &edge, &application: ApplicationType, &type-variable: TypeVariable>}
    TypeVariable    = Name
    RowType         = {&rows: ∃s∈Shape. array s {&label: Lookup, &type: maybe TypeValue}, &polymorphic: ∃s∈Shape. array s Name}
    ApplicationType = {&from: ∃s∈Shape. array s TypeValue, &to: TypeValue}
    Expression      = {&literal: Literal, &lookup: Lookup, &juxtaposition: Juxtaposition}
    Literal         = <&text: Text, &int: Int, &float: Float, &product: Product, &sum: Sum>
    Product         = ∃s∈Shape. array s <&raw-label: Lookup, &value: {&label: Lookup, &type: maybe TypeValue, &value: Expression}>
    Sum             = <&raw-label: Lookup, &value: {&label: Lookup, &type: maybe TypeValue, &value: Expression}>
    Lookup          = <&name: Name, &label: Label>
    Juxtaposition   = ∃s∈Shape. array s <&literal: Literal, &lookup: Lookup, &brackets: Expression>
  %end types
  %type AST = tree.

  ※ Universe

  %type Universe = μuniverse. {&modules: ∃shape∈Shape. array shape Modules, &bindings: }

  ※ The reader is a pure function that operates on a state, and a character.
  ※ The universe reference is in order to get access to a mutable readtable, and other related reading hooks
  %type internal-state = <
    &in-progress: Text, &done: AST
  >.
  %type reader-state = {&1: internal-state, &2: scopes} 
  %type reader-external-state = <&more-please: reader-state, &runnable-fragment: {&ast: AST, &reader-state: reader-state}, &done, &push: reader-state, &pop: reader-state>.
  %function incremental-read: (universe: Universe, state: reader-state, char: maybe character) → reader-external-state
  §incremental-read

  coprogram loop
    initialise universe.
    in stream characters char.
    
    var state: reader-external-state.
    state ← <&more-please ⇒ blank-reader-state>
    switch state
      acase &more-please →
        state ← incremental-read @@ it (pull char).
      acase &runnable-fragment →
        return-buffer ← eval @@ (&ast it)
        state ← <&more-please ⇒ (&reader-state it)>
      acase &done
        end loop.
      acase &push →
        create-new-scope @@ (&2 it).
        state ← <&more-please ⇒ it>
      acase &pop →
        close-scope @@
        state ← <&more-please ⇒ it>
    end switch
  §loop

§Prelude
