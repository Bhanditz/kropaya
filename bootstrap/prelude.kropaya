module Prelude
exports
  loop
  read
  eval
  print
  mirror
  universe
  @i/m/tagged/exported-types
begin
※ The start of the prelude 'contains' a number of Edges which are inserted initially by magic
※ Many of these are for basic types, and other things that are needed to get the initial machinery running

※ Some common types
type maybe a = <&some: a, &none>
type either a b = <&left: a, &right: b>
type list a = {&car: a, &cdr: <&list: list a, &end>}

※ AST types - these are fairly strongly tied to an implementation of read, eval, and mirror
types (μ tree forest Name Quantifier Arguments Module Program Coprogram Procedure Function Combinator Let TypeDeclaration TypeValue TypeVariable RowType ProductType SumType ApplicationType Expression Literal Product Sum Lookup Juxtaposition)
  forest = array tree.
  tree = <
    &module:     Module,
    &program:    Program,  ※ Eventually: must be total and have termination properties
    &coprogram:  Coprogram, ※ Eventually: must be total and have liveness properties
    &procedure:  Procedure,
    &function:   Function, ※ Functions are pure
  ※  &predicate:  Predicate,  ※ Implement this later
    &combinator: Combinator,
  ※  &method:     Method,  ※ Implement this later
  ※  &multi:      Multi,   ※ Implement this later
    &let:        Let,
    &type:       TypeDeclaration,
    &expression: Expression
  >.

  Name            = <&literal: Text> ※ Have more kinds of names later - this is needed for doing 'capabilities' the way I want to
  Quantifier      = <&type: <&lambda, &mu, &forall, &exists, &fresh>, &bound: Name>
  Arguments       = array {&name: Name, &type: TypeValue}
  Module          = {&name: Name, &quantifiers: array Quantifier, &exports: array Name, &code: forest}
  Program         = {&name: Name, &inputs: Arguments, &code: forest}
  Coprogram       = {&name: Name, &inputs: Arguments, &code: forest}
  Procedure       = {&name: Name, &inputs: Arguments, &output: TypeValue, &code: forest}
  Function        = {&name: Name, &inputs: Arguments, &output: TypeValue, &code: forest}
  ※ Predicate      = {&name: Name, &inputs: Arguments, &output: ???, &code: forest}
  Combinator      = {&name: Name, &inputs: Arguments, &output: TypeValue, &code: forest}
  Let             = {&arguments: array {&name: Name, &value: Expression}, &code: forest}
  TypeDeclaration = {&name: Name, &inputs: Arguments, &value: TypeValue}
  TypeValue       = <&row: RowType, &product: ProductType, &sum: SumType, &edge, &application: ApplicationType, &type-variable: TypeVariable> ※ Add Quantifiers when I can figure out how exactly
  TypeVariable    = Name
  RowType         = array {&label: Lookup, &type: maybe TypeValue}
  ProductType     = array {&label: Lookup, &type: maybe TypeValue}
  SumType         = array {&label: Lookup, &type: maybe TypeValue}
  ApplicationType = {&from: array TypeValue, &to: TypeValue}
  Expression      = {&literal: Literal, &lookup: Lookup, &juxtaposition: Juxtaposition}
  Literal         = <&text: Text, &int: Int, &float: Float, &product: Product, &sum: Sum>
  Product         = array <&raw-label: Lookup, &value: {&label: Lookup, &type: maybe TypeValue, &value: Expression}>
  Sum             = <&raw-label: Lookup, &value: {&label: Lookup, &type: maybe TypeValue, &value: Expression}>
  Lookup          = <name: Name, &label: Label>
  Juxtaposition   = array <&literal: Literal, &lookup: Lookup, &brackets: Expression>
end types
type AST = tree.

※ The reader is a pure function that operates on a state, and a character.
※ The universe reference is in order to get access to a mutable readtable, and other related reading hooks
type internal-state = <
  &in-progress: Text, &done: AST
>.
type reader-state = {&1: internal-state, &2: scopes} 
type reader-external-state = <&more-please: reader-state, &runnable-fragment: {&ast: AST, &reader-state: reader-state}, &done, &push: reader-state, &pop: reader-state>.
function incremental-read: (universe: Universe, state: reader-state, char: maybe character) → reader-external-state
§incremental-read

coprogram loop
  initialise universe.
  in stream characters char.
  
  var state: reader-external-state.
  state ← <&more-please ⇒ blank-reader-state>
  switch state
    acase &more-please →
      state ← incremental-read @@ it (pull char).
    acase &runnable-fragment →
      return-buffer ← eval @@ (&ast it)
      state ← <&more-please ⇒ (&reader-state it)>
    acase &done
      end loop.
    acase &push →
      create-new-scope @@ (&2 it).
      state ← <&more-please ⇒ it>
    acase &pop →
      close-scope @@
      state ← <&more-please ⇒ it>
  end switch
§loop

§Prelude
