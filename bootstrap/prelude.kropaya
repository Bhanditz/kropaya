module Prelude
exports
  loop
  read
  eval
  print
  mirror
  universe
  @i/m/tagged/exported-types
begin
※ The start of the prelude 'contains' a number of Edges which are inserted initially by magic
※ Many of these are for basic types, and other things that are needed to get the initial machinery running

※ Some common types
※ type maybe a = <&some: a, &none>
type maybe = ∃a. <&some: a, &none>
※ type either a b = <&left: a, &right: b>
type either = ∃a. ∃b. <&left: a, &right: b>
※ type list a = <&end, &cons: {&car: a, &cdr: list a}> 
type list = ∃y. μx. <&end, &cons: {&car: y, &cdr: x}>
type arbitrary-list = μx. <&end, &cons: ∃y. {&car: y, &cdr: x}>
※ arbitrary-list is used like so:
※ <&cons ⇒ {&car ⇒ 3, &cdr ⇒ <&cons ⇒ {&car ⇒ "Foo", &cdr ⇒ <&end>} ← Text>} ← Number>

※ Some monadic functions on common types

※ Some functions

case : ∀ match-label match-type other-cases result. {match-label:(match-type→result) |other-cases} → <match-label:match-type |other-cases> → result.
case pattern it = (match-label pattern) (match-label it).

id : ∀x. x → x.
id x = x

※ Usage:
※ show : either Text Text → Eff IO
※ show result = print (case {&left ⇒ \x → "error: #{x}", &right ⇒ id} result)

※ AST types - these are fairly strongly tied to an implementation of read, eval, and mirror
types (μ tree forest Name Quantifier Arguments Module Program Coprogram Procedure Function Combinator Let TypeDeclaration TypeBlock TypeValue TypeVariable RowType ApplicationType Expression Literal Product Sum Lookup Juxtaposition)
  forest = array tree.
  tree = <
    &module:     Module,
    &program:    Program,  ※ Eventually: must be total and have termination properties
    &coprogram:  Coprogram, ※ Eventually: must be total and have liveness properties
    &procedure:  Procedure,
    &function:   Function, ※ Functions are pure
  ※  &predicate:  Predicate,  ※ Implement this later
    &combinator: Combinator,
  ※  &method:     Method,  ※ Implement this later
  ※  &multi:      Multi,   ※ Implement this later
    &let:        Let,
    &type:       TypeDeclaration,
    &types:      TypeBlock,
    &expression: Expression
  >.

  Name            = <&literal: Text> ※ Have more kinds of names later - this is needed for doing 'capabilities' the way I want to
  Label           = <&name: Text> ※ Have more kinds of labels later - this is needed for 'label variables' and 'capabilities'
  Quantifier      = <&type: <&lambda, &mu, &forall, &exists, &fresh>, &bound: array Name>
  Arguments       = array {&name: Name, &type: TypeValue}
  Module          = {&name: Name, &quantifiers: array Quantifier, &exports: array Name, &code: forest}
  Program         = {&name: Name, &inputs: Arguments, &code: forest}
  Coprogram       = {&name: Name, &inputs: Arguments, &code: forest}
  Procedure       = {&name: Name, &inputs: Arguments, &output: TypeValue, &code: forest}
  Function        = {&name: Name, &inputs: Arguments, &output: TypeValue, &code: forest}
  ※ Predicate      = {&name: Name, &inputs: Arguments, &output: ???, &code: forest}
  Combinator      = {&name: Name, &inputs: Arguments, &output: TypeValue, &code: forest}
  Let             = {&arguments: array {&name: Name, &value: Expression}, &code: forest}
  TypeDeclaration = {&name: Name, &inputs: array TypeVariable, &value: TypeValue}
  TypeBlock       = {&quantifiers: array Quantifier, &declarations: array TypeDeclaration}
  TypeValue       = <&row: RowType, &product: RowType, &sum: RowType, &edge, &application: ApplicationType, &type-variable: TypeVariable> ※ Add Quantifiers when I can figure out how exactly
  TypeVariable    = Name
  RowType         = {&rows: array {&label: Lookup, &type: maybe TypeValue}, &polymorphic: array Name}
  ApplicationType = {&from: array TypeValue, &to: TypeValue}
  Expression      = {&literal: Literal, &lookup: Lookup, &juxtaposition: Juxtaposition}
  Literal         = <&text: Text, &int: Int, &float: Float, &product: Product, &sum: Sum>
  Product         = array <&raw-label: Lookup, &value: {&label: Lookup, &type: maybe TypeValue, &value: Expression}>
  Sum             = <&raw-label: Lookup, &value: {&label: Lookup, &type: maybe TypeValue, &value: Expression}>
  Lookup          = <&name: Name, &label: Label>
  Juxtaposition   = array <&literal: Literal, &lookup: Lookup, &brackets: Expression>
end types
type AST = tree.

※ The reader is a pure function that operates on a state, and a character.
※ The universe reference is in order to get access to a mutable readtable, and other related reading hooks
type internal-state = <
  &in-progress: Text, &done: AST
>.
type reader-state = {&1: internal-state, &2: scopes} 
type reader-external-state = <&more-please: reader-state, &runnable-fragment: {&ast: AST, &reader-state: reader-state}, &done, &push: reader-state, &pop: reader-state>.
function incremental-read: (universe: Universe, state: reader-state, char: maybe character) → reader-external-state
§incremental-read

coprogram loop
  initialise universe.
  in stream characters char.
  
  var state: reader-external-state.
  state ← <&more-please ⇒ blank-reader-state>
  switch state
    acase &more-please →
      state ← incremental-read @@ it (pull char).
    acase &runnable-fragment →
      return-buffer ← eval @@ (&ast it)
      state ← <&more-please ⇒ (&reader-state it)>
    acase &done
      end loop.
    acase &push →
      create-new-scope @@ (&2 it).
      state ← <&more-please ⇒ it>
    acase &pop →
      close-scope @@
      state ← <&more-please ⇒ it>
  end switch
§loop

§Prelude
