module Prelude
exports
  loop
  read
  eval
  print
  mirror
  universe
  @i/m/tagged/exported-types
begin
※ The start of the prelude 'contains' a number of Edges which are inserted initially by magic
※ Many of these are for basic types, and other things that are needed to get the initial machinery running

※ Some common types
type maybe a = <&some: a, &none>
type either a b = <&left: a, &right: b>
type list a = {&car: a, &cdr: <&list: list a, &end>}

※ AST types - these are fairly strongly tied to an implementation of read, eval, and mirror
type forest = array tree.
type tree = <
  &module:     Module,
  &program:    Program,  ※ Eventually: must be total and have termination properties
  &coprogram:  Coprogram, ※ Eventually: must be total and have liveness properties
  &procedure:  Procedure,
  &function:   Function, ※ Functions are pure
※  &predicate:  Predicate,  ※ Implement this later
  &combinator: Combinator,
※  &method:     Method,  ※ Implement this later
※  &multi:      Multi,   ※ Implement this later
  &let:        Let,
  &type:       TypeDeclaration,
  &expression: Expression
>.
type Name            = <&literal: Text> ※ Have more kinds of names later - this is needed for doing 'capabilities' the way I want to
type Quantifier      = <&type: <&lambda, &mu, &forall, &exists, &fresh>, &bound: Name>
type Module          = {&name: Name, &quantifiers: array Quantifier, &exports: array Name, &code: forest}
type Program         = {&name: Name, &inputs: Arguments, &code: forest}
type Coprogram       = {&name: Name, &inputs: Arguments, &code: forest}
type Procedure       = {&name: Name, &inputs: Arguments, &output: Value, &code: forest}
type Function        = {&name: Name, &inputs: Arguments, &output: Value, &code: forest}
※type Predicate      = {&name: Name, &inputs: Arguments, &output: ???, &code: forest}
type Combinator      = {&name: Name, &inputs: Arguments, &output: Value, &code: forest}
type Let             = {&arguments: array {&name: Name, &value: Value}, &code: forest}
type TypeDeclaration = {&name: Name, &inputs: Arguments, &value: TypeValue}
type TypeValue       = <&row, &product, &sum, &edge, &application> ※ TODO
type Expression      = {&literal: Literal, &lookup: Lookup, &juxtaposition: Juxtaposition}
type Literal         = <&text: Text, &int: Int, &float: Float, &product: Product, &sum: Sum>
type AST = tree.

※ The reader is a pure function that operates on a state, and a character.
※ The universe reference is in order to get access to a mutable readtable, and other related reading hooks
type internal-state = <
  &in-progress: Text, &done: AST
>.
type reader-state = {&1: internal-state, &2: scopes} 
type reader-external-state = <&more-please: reader-state, &runnable-fragment: {&ast: AST, &reader-state: reader-state}, &done, &push: reader-state, &pop: reader-state>.
function incremental-read: (universe: Universe, state: reader-state, char: maybe character) → reader-external-state
§incremental-read

coprogram loop
  initialise universe.
  in stream characters char.
  
  var state: reader-external-state.
  state ← <&more-please ⇒ blank-reader-state>
  switch state
    acase &more-please →
      state ← incremental-read @@ it (pull char).
    acase &runnable-fragment →
      return-buffer ← eval @@ (&ast it)
      state ← <&more-please ⇒ (&reader-state it)>
    acase &done
      end loop.
    acase &push →
      create-new-scope @@ (&2 it).
      state ← <&more-please ⇒ it>
    acase &pop →
      close-scope @@
      state ← <&more-please ⇒ it>
  end switch
§loop

§Prelude
